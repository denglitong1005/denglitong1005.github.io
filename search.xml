<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解Rust中的类型设计 - Objects and behavior]]></title>
    <url>%2F2019%2F11%2F17%2Frust-data-type%2F</url>
    <content type="text"><![CDATA[数据类型是编程语言的基石。数据类型之于编程语言，就像26个字母之于单词、偏旁部首之于汉字，是构成程序语句最基础的元素，是我们编写statement/expression的literal，从本文开始我会涵盖Rust中常用的数据类型介绍和简单使用。 当今的许多编程语言都有多重编程范式设计，又称多范式编程语言（Multi-paradigm programming language），例如Java/Golang，但他们还停留在聚焦于对象继承原则，这也就是说它们会有classs、interfaces、class inheritance这些，而这些没有一个出现在Rust中，这也是造成很多人觉得Rust的学习曲线很陡的原因之一。Rust作为一个多重范式设计的语言，有很多函数式的概念和范式，而这些会使得应用传统的对象继承模式变得困难。与通过类classs和接口interfaces来组织代码不同的是，Rust使用struct和trait(特质)。下面就让我们开始探索，Rust中的独特设计究竟是怎样的一番体验，以及这些设计如何影响我们使用Rust中的数据结构来进行算法编程。 对象和行为 首当其冲的便是传统OOP语言中的类和继承机制。如果你写过OOP那么你对下面的这段代码将了如指掌： 1234567class Door &#123; private bool is_open = false; public void Open() &#123; this.is_open = true; &#125;&#125; 而在Rust语言中，这个模式定义要求所有Door的实例都拥有可变性，而可变性就涉及显示加锁以保证线程安全。与此同时，如果有新增一个类GlassDoor，这时如果没有类的继承机制那么就会产生重复的is_open定义，而重复代码将使得维护变得困难。 可变性mutability，在此处是Door实例对其内部数据is_open做出修改的能力。在Rust中所有变量默认都是不可变的，参见：rust-lang/rfcs#1 Rust建议使用trait实现共享的行为，Rust中的trait，中文译作特质，很像OOP语言中的虚类（trait的方法可以有默认实现，虚类也支持默认实现），Rust中的struct可以实现多个trait，下面是一个示例： 12345678910111213141516171819struct Door &#123; is_open: bool&#125;impl Door &#123; fn new(is_open: bool) -&gt; Door &#123; Door &#123; is_open: is_open &#125; &#125;&#125;trait Openable &#123; fn open(&amp;mut self);&#125;impl Openable for Door &#123; fn open(&amp;mut self) &#123; self.is_open = true; &#125;&#125; 使用类比，struct Door{} 的定义可以看成是OOP编程语言中的class，而 impl Door{} 块则类比class中的方法实现，trait Openable{} 则类比interface的定义，impl Openable for Door{} 在Rust中是为某个struct实现某个trait的功能，可类比OOP中实现一个interface。对比是为了参照理解，但绝不是只是换个名词，它体现的是Rust的设计思想：数据结构定义和行为实现分离，行为实现可插拔。 传统OOP语言中的类，把数据成员和方法实现糅杂在一起，虽然C++可以用头部文件.h把定义和实现区分开但并不是强制性的。而Rust强制把这两者区分开了，做法就是通过声明一个struct，以及一个impl块来承载struct中具体拥有哪些方法和具体实现。与此同时Rust可以为struct实现多个trait，这使得trait的导入、共享、复用变得简单。利用trait和generics泛型可以为已有struct真正无侵入的增加新trait的实现，下面就来展示一下。 假设我们已经有了一个分页的struct MyPaginate用来保持当前页数，以及对应的trait用来设置当前的页数和每页的条数，它们像下面这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546trait Page &#123; fn set_page(&amp;mut self, p: i32);&#125;trait PerPage &#123; fn set_perpage(&amp;mut self, num: i32);&#125;#[derive(Debug)]struct MyPaginate &#123; page: i32, per_page: i32,&#125;impl MyPaginate &#123; fn member_method(&amp;self) &#123; println!("This is member method for struct which no relevant to trait."); &#125;&#125;impl Page for MyPaginate &#123; fn set_page(&amp;mut self, p: i32) &#123; self.page = p; &#125;&#125;impl PerPage for MyPaginate &#123; fn set_perpage(&amp;mut self, per_page: i32) &#123; self.per_page = per_page; &#125;&#125;#[cfg(test)]mod tests &#123; #[test] fn test_trait_not_inherit() &#123; let mut my_paginate = MyPaginate &#123; page: 1, per_page: 10, &#125;; my_paginate.set_page(2); my_paginate.set_perpage(100); println!("my_paginate: &#123;:?&#125;", my_paginate); // output: my_paginate: MyPaginate &#123; page: 2, per_page: 100 &#125; &#125;&#125; 上面定义了2个trait并为struct实现了这2个trait，到这里还显示不出Rust中的trait有什么特别的地方，让我们接着往下看。假如这时我们需要引入一个新的trait并增加一个方法set_skip_page，希望能够设置可以跳过的页数，这个时候如何添加到代码中去呢？如果是在C中，接口是由抽象类来实现，而由于C只能单继承，如果要引入新的方法实现，那么我们势必需要在现有的抽象类/子类中新增方法实现，这就会侵入现有代码。而在Java中，接口通过interface来实现，类可以继承多个interface，如果我们要新增一个方法实现，我们可以引入新的interface，这样可以不改动已有的interface代码，但至少还得修改类定义新增一个 extends interface的声明。而在Rust中，上述2种情况都不需要修改！这得益于Rust中的generics和trait，给代码提供了强大的灵活性和表达性，下面看代码示例： 12345678910111213141516171819202122232425// 声明了一个新`trait`trait Paginate &#123; fn new_method(&amp;self, page: i32);&#125;// 为MyPaginate实现新traitimpl Paginate for MyPaginate &#123; fn new_method(&amp;self, page: i32) &#123; println!("In new_method, page: &#123;&#125;", page); &#125;&#125;#[cfg(test)]mod tests &#123; #[test] fn test_new_trait() &#123; let mut my_paginate = MyPaginate &#123; page: 1, per_page: 10, &#125;; my_paginate.member_method(); my_paginate.new_method(10); // output: In new_method, page: 10 &#125;&#125; 上面的例子是新增一个独立的trait实现，可以看到Rust可以在真正零侵入原struct和trait的情况下，为struct实现了新trait的方法！这是不是比C++/Java更灵活呢？而且，结合trait inherienceRust还能实现更强大的功能。下面来看一个需求，假设你的需求是新增一个新trait实现，但是实现这个trait的前提是你需要先实现Page，但是你又希望在设计上将两者区分开而不是糅杂在一起，这个时候trait inherience就派上用场了，看例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 1.第一种语法为MyPaginate声明实现Paginate trait，Paginate需要依赖于Pageimpl Paginate for MyPaginate// where限定符声明了该实现针对的MyPaginate类型需要先实现了Page trait，// 这是因为新增的方法实现用到了Page trait中的set_page函数where MyPaginate: Page,&#123; fn set_skip_page(&amp;mut self, page: i32) &#123; self.set_page(page + 1); &#125;&#125;#[cfg(test)]mod tests &#123; #[test] fn test_trait_inherit() &#123; let mut my_paginate = MyPaginate &#123; page: 1, per_page: 10, &#125;; my_paginate.set_page(1); my_paginate.set_perpage(100); my_paginate.set_skip_page(12); println!("my_paginate: &#123;:?&#125;", my_paginate); // output: my_paginate: MyPaginate &#123; page: 13, per_page: 100 &#125; &#125;&#125;// 以上是针对单个具体类型MyPaginate为其实现了Paginate实现，// 而Rust的泛型提供了更强大便捷的语法，可以为所有符合要求的类型实现Paginate，请看：// 2.声明trait的时候使用继承语法，表示实现PaginateInherit trait之前需要先实现Page traittrait PaginateInherit: Page &#123; fn set_skip_page_inherit(&amp;mut self, page: i32);&#125;// 为实现了Page的类型T实现PaginateInherit，也就是为目标类型实现PaginateInherit trait而已impl&lt;T: Page&gt; PaginateInherit for T &#123; fn set_skip_page_inherit(&amp;mut self, page: i32) &#123; self.set_page(page + 1); &#125;&#125;// 而在此处的上下文中我们已实现了 impl Page for MyPaginate &#123;&#125;// 所以此时MyPaginate就自动实现了PaginateInherit！#[cfg(test)]mod tests &#123; #[test] fn test_trait_inherit() &#123; let mut my_paginate = MyPaginate &#123; page: 1, per_page: 10, &#125;; my_paginate.set_page(1); my_paginate.set_perpage(100); my_paginate.set_skip_page_inherit(12); println!("my_paginate: &#123;:?&#125;", my_paginate); // output: my_paginate: MyPaginate &#123; page: 13, per_page: 100 &#125; &#125;&#125; 综上，我们展示了Rust如何使用struct和trait（特质）将数据结构定义和行为实现相分离，Rust推荐优先使用组合而不是继承。通过将数据结构和行为实现相分离，不仅仅是编码语法上的改变，更是从设计思想上出发，将现实世界中的数据和行为抽象解耦，使多变的行为得以灵活扩展而不必影响少变的数据结构定义或干扰已有行为定义和实现。这将大大提高我们对现实的抽象灵活表达能力，而这，也将有助于我们打造出更安全可靠的系统，你觉得呢？]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Hands-On Data Structures and Algorithms with Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust入门简介]]></title>
    <url>%2F2019%2F11%2F16%2Fhello-rust%2F</url>
    <content type="text"><![CDATA[前段时间一个偶然的机会了解到了 Rust 这门语言，随机就被它的Slogon俘获了：A language empowering everyone to build reliable and efficient software. Rust能够在编译期间就确保内存安全、提供和C/C++同级别的高性能、还有并发、异步、函数编程、强大的宏等等特性，并且很重要的一点是整个Rust社区很友好，而且Rust的工程学用起来体验很好。随着了解的越多，被种草的程度就越深，虽然现在学习到的Rust知识还很少（Rust的中文资料相对较少），但基本确定了会一直学习下去的，希望在未来Rust的许多设计思想可以普及开来，比如内存安全的思想、软件工程学等等。 内存安全的意思，可以简单理解为编译通过的程序里不会在运行时出现空指针/悬垂指针。 我相信写过C/C++/JAVA代码的同学都有遇到过空指针异常的，而很多软件漏洞都是内存泄露/空指针造成的， 如果你有过在某个深夜排查空指针异常Bug的经历，你就会明白内存安全是多么的具有吸引力！ 想象一下你很有自信发布代码，因为你知道不会出现内存安全问题，是不是很期待？ （特别是当你涉及交付产品给终端用户的时候就更能体会到这种感觉了，比如一些安全敏感的应用，如金融、医疗等等） 下面，就请跟随我的脚步，来简单的了解一下Rust这门语言，看看它和其他已有的语言和哪些不同，我们可以从这些差异点中进行学习借鉴。 选择Rust的三大理由 首先来看到Rust官网首页列出的选择Rust的三大理由： 高性能：Rust是一个没有GC的语言，并且几乎没有运行时开销，可以胜任对性能要求特别高的场景，不会因为GC而导致程序的“暂停”。同时Rust依靠独特的Ownership和Lifetimes的设计，使得其内存利用率极高，不会像JAVA程序那样把所有的内存吃光，相反，使用Rust编写的程序在保持高性能的同时还能做到内存资源占用少，在节省服务器资源的同时可以让我们更有信心应对更严酷的场景。 可靠性：Rust可靠性前面有提到一点，就是内存安全，其实Rust还可以保证线程安全，在进行多线程进行并发/异步的同时，不会出现Data Racing的问题，而Data Racing是其他编程语言中多线程并发绕不过的问题。而这些特性，都得益于Rust丰富的Type系统和Ownership机制。 生产力：上手Rust给我的体验是，这是一门工程学设计良好的语言。集构建、测试、文档、发布于一体的开发工具Cargo和crates.io，更简约友好的命名规范，能减少大量样板代码的宏以及库函数。举2个例子来感受一下，函数声明，Go中使用func(){}，而Rust则更进一步使用fn(){}，也许你会觉得这只是几个字符的差别，但远远不止，它体现出Rust精简的设计思想。比如输出语句，Go中需要先导入import fmt然后再使用fmt.Println()，而Rust强大的宏更进一步无需导入任何包直接使用println!()就可以打印到控制台。诸如此类的还有许多，它体现出的是在开发过程中提升开发人员的效率，工程学友好，Rust刷新了我对这个词的理解。 Rust的发展历史和生态现状 Rust最开始是2006年Graydon Hoare设计的私人项目，其后在2009年Mozilla（Firefox的母公司）决定赞助这个项目，并在2010年首次对外公开。同年，Rust的编译器rustc的源代码由OCaml语言转移到用Rust语言（进行bootstrapping自举），并于2011年实际完成，这个可自我编译的编译器采用了LLVM作为它的后端。rustc的第一个公开版本发布是在2012年1月，Rust在2015年5月15日发布了它的第一个稳定版本Rust 1.0。截止到文本撰写时，Rust发布了它的最新的版本Rust 1.39.0，期待已久的async/await特性终于稳定了。 其中Rust在Mozilla被用来了整个重构重写了FireFox的核心组件，足以证明Rust能够胜任大型软件的开发重构工作。 Rust的发展方面，与之可以比对的是时下流行的Go语言。Rust和Go几乎是同时出来的语言，都是在2009年左右。Go语言伴随着Docker/Keburnetes容器编排、微服务技术潮流的兴起，可以说是增长势头迅猛。反观Rust，每一个特性设计都讨论好久，前期的版本变化太大，很多设计都推倒重来（比如是否要有GC），直到1.0版本出来后才趋于稳定（值得注意的是Golang 1.0的版本发布时间是2012年3月，Rust与之相比晚了3年多才发布1.0版本）。这在一定程度上延缓了Rust的普及，但也因此造就了Rust独特的设计理论、良好的社区文化以及友好的工程学体验。虽然没有Google这个好爹的背书，但是Rust无运行时开销的高性能和无畏安全的线程并发能力、工程学效率，我相信会越来越受到欢迎的。 下面引用Rust的一则报道加以补充： 目前，Rust发展势头正劲。此前，微软安全响应中心探索采用 Rust 的消息引发大量关注，在连续四年蝉联“最受开发者喜爱的编程语言”后，Rust 可能已经从“想要学习的语言”逐渐转变为许多开发者“正在学习的语言”。自从四年前首次发布稳定版以来，它已经得到了广泛的采用，谷歌，微软和 Mozilla 等公司都在使用 Rust。现在，AWS 也向 Rust 伸出了橄榄枝。 至于Rust的生态方面，使用Rust几乎能做任何事情：可以编写底层应用操作系统，可以进行Web开发、嵌入式开发，还可以利用WebAssembly将Rust代码运行在浏览器中。来一张官网的图感受一下： 关于Rust 2018年的Road Map可以参见：https://blog.rust-lang.org/2018/03/12/roadmap.html。 不过Rust现在的一些基础库还不够完善，还需要更多的开发者加入添砖加瓦。 未来的互联网，随着5G的普及，注重安全和高性能是必然趋势，而Rust正是这样的一门可以赋予每个人无畏的构建安全高性能的语言。借助Rust，我相信可以摆脱系统对架构集群的过度依赖，构建出安全、高性能、设计简约的轻型系统。下一篇文章，我将继续带领大家，来理解Rust中的数据类型。 最后，附上学习Rust的资源链接： Rust Programming Language The Rust Programming Language Forum Rust Language (@rustlang) / Twitter Rust - MozillaWiki The Rust Programming Language Blog Introduction - The Rust RFC Book This Week in Rust Baby Steps - Nicholas D. Matsakis Rust Playground Rust语言中文社区-首页 Rust Force - 关于 Rust 编程语言的一切]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Hands-On Data Structures and Algorithms with Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务引发的一次线上Bug]]></title>
    <url>%2F2019%2F11%2F16%2Fmysql-transacion-with-proxy%2F</url>
    <content type="text"><![CDATA[上篇博文里谈到，我最近在做的是组内的一个客服场景下的即时聊天框，前两周的周五赶马上线了。在测试环境测试一切正常，上线后…就翻车了…当时赶着上线，是在周五开完周会之后我和另一个组员一起上线的。那晚数据库还是临时找DBA给申请的，然后上线后我才把之前一条应该刷的SQL给刷了…所以赶着上线真的不是一件好事，在实际开发过程中要尽量避免，这次案例就引以为戒吧。 先来描述一下故障表现：我们上线之后，在用户向服务方发起在线咨询时后台会生成一个群聊记录 os_group，此时问题就出现了，前端调用接口获取到的群聊成员列表都是空的，用户发起群聊后却看不到群聊中的任何成员，数据异常，而且多次测试中还偶然有正常的。 到这里是我们始料未及的，在测试环境我们测试了一周都没有出现这个现象，此时我的第一反应，在确认接口返回的数据确实有问题后，先在脑海里过一遍，有没有可能是代码哪个环节没考虑到导致了这个问题。在确定没有直接能判断到可能的源头后，开始了排查。首先通过跳板机连接到线上的数据查看相关的数据是否插入正常，一查询发现获取群成员列表接口中的 group_id: 0 在数据库表中确实也是0，这基本就锁定了是我们连MySQL出了问题。异常的数据截图如下： 接着顺藤摸瓜，找到了代码中插入群聊的位置： 这里解释一下：75行之前把要创建群聊的前置条件都准备好，然后调用 dao.insertSelective(groupDO) 进行数据插入，初始化好群聊记录后，接着初始化群成员关系 initGroupUsers()，其中就用到了群聊Id groupDO.getId()。用过ORM框架的朋友们都知道，insert 方法都会将插入那行数据的 id 返回并设置到dao对象中，在此处也即 groupDO 中，然后后续初始化群成员关系的时候就会用到。问题也就是出现在这里，插入后的dao对象的id从效果上看并没有返回设置对应的id，导致初始化群成员关系的时候 group_id 都是0，从而导致了在前端页面数据异常，新建的群聊没有任何成员显示。 到这里问题基本就确定了，是MySQL连接的问题。一开始我们怀疑是临时申请的数据库哪个设置没配（因为在申请数据库的时候DBA跟我说还有一个操作是初始化），不过在和DBA拉群沟通的时候，DBA表示配置都是标准化的并没有遗漏。这时我的另一个组员，也就是这次一起上线的那位，说他之前就遇到过一次DBA申请的数据库在挂了MiProxy之后存在数据同步不一致的问题（MiProxy是MySQL前面的一层代理，是DBA用来做负载均衡的，如果直接连接MySQL后端的话是没有负载均衡的）。这时候我们继续跟DBA沟通，DBA让我们优先排查代码的问题，虽然之前MiProxy出现过主从同步不一致的问题，但遇到客户端不兼容的情况还是极少的。并让我们贴出了有问题的代码： 这段代码看起来没有问题，先insert然后再select最新的LAST_INSERT_ID()。这时候我们分别去验证数据库连接的问题：DBA验证MiProxy的问题，我们验证程序的问题，我们在线上把这个组件的数据库切换到staging环境后就好了，插入的id是能查到的不再为空了，同时DBA那边也用脚本验证了MiProxy的连接是没有问题的： 到这里我们综合以上信息，脚本使用pymysql.connect()连接线上MiProxy，在同一个打开的connection里面insert/select都是没有问题的；而程序中使用了MyBatis Plus进行连接MiProxy就有问题，但是程序连接staging环境的库没有问题，同时线上库和staging库的区别在于一个是直连的、一个是使用MiProxy连接的；再结合多次测试中还是偶有能正确插入的，这个时候我们就想到可能是MySQL连接多线程的问题，使用单个连接没有问题，可以排除数据库配置、驱动版本的问题，而使用MiProxy连接后就不正常了，MiProxy提供代理能力，其后面屏蔽掉了可能有多个mysql connection线程，而程序代码中的select/inset有2次读写操作，需要先写入然后再去读取，如果这2个操作不在同一个后端MiProxy的connection线程中，则其执行的先后顺序得不到保障，比如select读取的线程总是先返回，那么插入的os_group表的最新的id便是不正确的，从而导致了每次读取到的os_group的id都是0。 到这里问题基本明朗了，是由于数据库代理引发的读写不同步的问题，之前同事就遇到过相关的配置问题，需要开启数据库的配置keep_session来保持会话信息。按理说这里我们也让DBA直接开启keep_session，这样select/insert就能在同一个连接里完成也就不会出现不同步的问题了。但是我的那位同事之前就遇到过开了keep_session之后，经过MiProxy提供的主从库有不同步的问题，所以这里我们并不能通过这个开关配置来最终解决问题。 怎么办呢？我们提议让DBA不要再走MiProxy了，我们想直连后端mysql。DBA不建议这样做，说还是有负载均衡比较好，可是开了keep_session之后又有主从不同步的可能问题，两边都不是。最后的最后，还是我们这边决定先在代码层面对相关的查询位置进行事务处理，明确声明让MiProxy后端放到同一个connection里处理，我们在Service层都加了Transactional注解： 我们在Service层都加了事务开启，这样确保了所有的SQL查询都在事务里，不会出现上述读写不同步的问题。可能到这里你会问所有的查询都开事务，MySQL读写的性能是不是会下降？那是肯定的，但是鉴于我们目前服务的阶段是处于快速上线验证的阶段，所以此次我们先临时fix一下，后面等业务量上来了如果确实性能跟不上，到时候再优化也不迟。 其实这里应该说是基础组件的问题，DBA提供的主从同步数据库有些场景功能满足不了，从而导致了当前的使用现状。 哎，基础设施不够完善啊，要想跑得快，还得底盘好，这话没毛病。 临时fix掉后我们重新部署，上线后再验证就没有这个问题了，总算是好事多磨，而此时已经是周五晚上接近9点了。不过这次上线也是应该要上的，因为项目Owner在周报里已经写了上线日期就是今天，中间出现的这些小插曲，说明我们项目管理这次做得不够好。 不幸中的万幸是，此次我们组件上线是有灰度的，只有开启了组件可见的服务才能看到我们的入口，而这次上线我们只开启了自己的服务可见，对其他服务来说是无感知的，这也体现了要想持续快速交付，无缝的灰度上线策略是必不可少的。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS长整型精度问题引发的一个Bug]]></title>
    <url>%2F2019%2F11%2F03%2Fjs-floating-point-precision%2F</url>
    <content type="text"><![CDATA[最近在做一个IM相关应用的后端接口工作，在前后端联调的过程中出现了一个因JS浮点数精度引发的bug，记录如下。 先简单的介绍下我正在做的工作，我们在做的事情是基于公司云平台的产品探索，目前小组负责的探索方向有反馈系统、技术社区、产品点评、需求发布等，而我所在的小组是反馈系统里面衍生的在线支持。在线支持需要连接服务方和用户方，这里的服务方可以理解为淘宝卖家，不过在我们云平台上是技术能力提供方（比如FDS/HBase等），而反馈系统和在线支持，就充当起淘宝旺旺的功能，给商家和用户建立一个渠道，方便快速接入用户并解答疑问，同时还基于内部Jira系统将用户数据提交成需求单/缺陷单/建议单等，进一步提升技术迭代速度、提升用户使用体验、助力业务领跑。 介绍完背景后，让我们来看下具体出现bug的场景： 我们第一版实现的是网页群聊，是基于小米开源的MIMC来实现的。其中获取用户群聊未读消息条数的逻辑，是基于MIMC回调消息和前端在收到消息后向后端更新已读的sequence来做的。举个例子就是群聊G发送了a,b,c三条消息，用户U上次已读消息的sequence号是a的sequence号，所以此时a在群聊G有2条未读消息（消息b,c都不是用户U发的），当用户点进群聊的时候，前端取最后一条消息的sequence向后端接口更新用户的已读消息sequence。到了这里一切看起来都没有问题，但是联调过程中出现了群聊未读消息更新不成功，多次更新后依然还是会有一条未读消息的现象… 首先观察接口返回，在chrome浏览器里面F12 preview看接口返回数据，初看起来获取到的sequence返回正常，然后再去看k8s里面pod的日志，前端-&gt;后端-&gt;MIMC-&gt;MIMC回调，一切交互逻辑也是OK的。此时仔细观察了数据库里面更新回来的sequence序列号，和日志中发送给MIMC也是一致的，这个时候再去看接口中显示的群聊历史消息的sequence，此时发现了一个问题：群聊历史消息接口获取到的sequence序列号总是比收到MIMC回调的sequence小1，而在浏览器中观察接口的返回发现，Preview里面预览看到的结果，和Response里面的结果相差1！问题就在这，如下图所示： 注意看红色圈出来的部分相差1，这就是导致sequence更新不正常的元凶！ 问题找到了，想到了可能是JS的精度问题，因为对JS了解的不多想着返回long型了也不是浮点数，怎么就不能精确表示了呢？看着也不像整型溢出，于是google了一下，了解到原来JS对所有的数字都使用64位浮点数表示，而浮点数虽然能表示范围很大，但是在一些大整数的时候存在不能精确表示的问题，比如上图中差1的情况，具体原因是因为在64位浮点数表示里面，只有52位是真正用来表示尾数部分的，而剩下的12位则用来表示指数和符号位，通过正规化，我们可以使用53位来表示尾数（+符号位），因此，64位浮点数能表示的尾数最大值是：2^53-1（9007199254740991），而我们接口中返回的157180098717096001远超过9007199254740991，从而JS不能精确的表示，出现了精度问题。stackoverflow上面的解释如图： 好了，到了这里终于是水落石出了，知道原因后要解决这个问题也很简单，那就是将返回字段的类型由long改为String，这样前端就能准确的获取到不会有精度问题，而且String类型也能满足我们的场景需要：群聊消息排序、更新已读sequence等。再补充一下，这里sequence使用long存储而不是String，是因为MIMC的SDK中返回的sequence就是long型的。 吃一堑，长一智。通过这个问题，我们深刻的理解了JS和前后端数据交互中可能存在的精度表达问题（准确来说是浮点数不能精确表示的问题，因为这里JS默认都使用了64位浮点数表示数字），针对这个问题NodeJs等也有自己的一个精确表示大整数数字的库来解决。作为后端开发的我们，平时多了解一下上下游的知识还是很有帮助的；再有一个就是，当时我遇到这个问题的时候，第一个感觉就是这个问题很有意思，激起了我的排查兴趣，虽然排查过程不算复杂，但是一个积极的心态对推进bug排查很有帮助的，用积极的心态去看待问题，把问题当做学习成长的机会，你将会活在当下。Coding in the moment. :-)]]></content>
      <categories>
        <category>Web</category>
        <category>Front-end</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朝花夕拾]]></title>
    <url>%2F2019%2F08%2F31%2Ffirst-post%2F</url>
    <content type="text"><![CDATA[在重写博客之际，感慨恒劳知逸、君子慎独、]]></content>
  </entry>
</search>
