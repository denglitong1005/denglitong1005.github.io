<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解Rust中的类型设计 - Borrowing and ownership]]></title>
    <url>%2F2019%2F11%2F23%2Frust-borrowing-and-ownership%2F</url>
    <content type="text"><![CDATA[Rust这门语言因为它的内存管理模型而闻名，它使用编译期检查代替了运行时的GC（垃圾回收）来确保内存安全。Rust能够做到没有GC但仍然能让程序员从易错的内存管理中解脱出来的秘诀就是：Borrowing and ownership，即借用检查和所有权设计，这个一个简约但并不简单的设计实现。 Stack &amp; Heap memory 特别的，程序中的内存管理是比较复杂的，一个高阶的视角是，内存管理对编译器而言总是”分配一定长度的内存“和”回收一定长度的内存“，这有点像C语言中的malloc()和free()函数。Rust中的所有权规则如下： 内存中一个值value的所有者owner是一个变量variable 在任何时刻，内存中的某个值value只有一个owner 内存中的某个值value在离开它的作用域scope时就会被回收 使用Rust中声明式的语法，比如在声明一个变量let a = &quot;hello&quot;;的时候，rustc编译器就会知道，在编译期间会为该变量分配有一定长度的内存，并对该段内存进行追溯。这个过程中会引入lifetimes生命周期这个机制，生命周期即是指该变量从开始声明到离开作用域被销毁的整个生命周期。如果变量是定长的，那么编译器就会分配指定大小的内存，比如为i32类型分配32bits，即4bytes。下面来看2个变量内存分配的例子： 123456789fn my_func() &#123; // the compiler allocates memory for x let x = LargeObject::new(); x.do_some_computation(); let y = call_another_func(); if y &gt; 10 &#123; do_more_things(); &#125;&#125; // deallocate(drop) x, y Rust编译器真的会按照上面的内存释放顺序执行吗？是也不是。这里的窍门是，静态代码分析模块会去检查每个变量的作用域到底到哪里就结束了，而不是等到函数执行完退出时才释放。那么问题就来了，如果一个线程在未知的运行时改变了一个变量那怎么办呢？在编译期的时候是不可能知道运行时所发生的动作的，这也是很多语言使用GC垃圾回收器来解决内存回收的原因。然而Rust并没有采用这个设计，Rust引入了两个基本策略： 每个变量在任何时刻只能被一个作用域scope拥有owner 基于第1点，变量在作用域之间传递须同时移交所有权（pass ownership） 在我们和作用域打交道的时候，使用栈内存stack是自然而然的事情。我们都知道内存有2种，一直是栈内存stack，一种是堆内存heap。和其他编程语言一样，Rust使用不同的数据类型来声明要分配栈内存，还是要分配堆内存，如基本类型、复杂类型，如Box, Rc等。 栈是一种后进先出的结构，通常生存周期短、数据类型简单、占用内存长度固定sized。下图是栈内存的示意： 而堆则与之不同，堆是一大块内存，可以方便的为复杂变量分配其所需的内存长度。在堆中变量的分配是无序的，已分配的变量通过内存地址来索引，即内存指针pointer，而内存指针的长度是定长的，它可以很好的存在栈上（内存指针的长度，是由当前CPU运行模式的寻址位数来决定的，一般64位处理器的内存指针长度为8bytes，32位处理器的内存指针长度为4bytes，而在堆上的变量其在栈的存储结构除了指向内存地址的起始指针之外还会有其他的元数据，比如内存长度等）。堆变量的表示示意图如下： Onwership &amp; Borrowing 典型的，在其他编程语言中，在栈上分配的变量会以值拷贝的方式进行传递，即将值在栈上复制一份到新分配的内存地址然后再使用。Rust也一样，不过Rust的所有权机制使得在scope之间传递时，如果栈上变量的所有权移交到新scope，那么旧scope的变量就会失效，无法再通过变量名访问到栈上原有的内容。下面是一个示例： 12345fn my_function() &#123; let x = 10; do_something(x); // ownership is moved here let y = x; // x is now invalid! unreachable&#125; 每个值只有一个变量拥有其onwership，值在不同scope间传递的时候需要进行move，想象一下当我们想在多个scope中访问同一个变量时，每个scope都进行move in move out将会很不方便，那么有没有一种机制可以在多个scope中访问到同一个变量呢？答案就是借用borrowing。使用borrowing传递进新的scope时，借用本身也会move in scope，但和值拷贝不同的是它不需要将原变量完整的值进行拷贝，借用只是原值的一个引用reference，它可以访问原有的值但不拥有其ownership。Borrowing的规则如下： Owners可以拥有不可变的immutable和可变的mutable的借用reference，但不能同时存在两者 可以存在多个不可变借用，但可变借用只能存在一个 还是上面的例子，使用借用进行scope间的传递，示例如下： 123456fn my_function() &#123; let x = 10; do_something(&amp;x); // pass a borrowing reference to x, // variable &amp;x is created and moved in scope let y = x; // x is still valid!&#125; 其实借用Borrowing深度依赖变量的生命周期lifetimes。想象一下你借用出去的reference后续访问原变量的时候需要保证内存安全，即不会出现访问内存错误的情况，这就需要知道原始变量和借用出去的引用的生存周期并保证原始变量存活的都比借用的引用要久。而借用会用在struct field等多层传递的复杂scope中，此时编译器如何确保知道变量的生命周期之间的存活周期约束呢？这就需要显示生命周期声明了！ Lifetimes Rust的生命周期参数声明使用一个'后跟标识符来标识，其中一个预定义的生命周期是'static，表示静态全局生命周期。 其实生命周期参数是很说得通的，想象一下你传了一个参数到函数里面，然后函数又把它返回回来，那么这个参数的生命周期就比这个函数的生命周期存活的久。同样，函数中声明的变量的生命周期只存活到函数执行结束时，所以不能借用一个在函数内部声明的变量。 1234567fn another_function(mut passing_through: MyStruct) -&gt; MyStruct &#123; let x = vec![1, 2, 3]; // passing_through cannot hold a reference to a shorter lived x! // the compiler will complian. passing_through.x = &amp;x; return passing_through;&#125; // x's life ends here 不能借用一个在函数内部声明的变量，这是因为引用它的变量比它存活的更久，不能确保将来想访问这个变量的时候它还存在在内存中。针对这种情况有以下几个解决方法： 将对函数内部声明变量的借用改为移交所有权，这样使用该变量的值直接拥有其所有权从而可以伴随着生命周期一直使用。 1234567fn another_function(mut passing_through: MyStruc) -&gt; myStruct &#123; let x = vec![1, 2, 3]; // passing_through owns x and it will live as long as with passing_through, // it's safe for passing_through use x, and finally they weill be dropped together passing_through.x = x; return passing_through;&#125; 第二个方式是将变量x进行clone一份给passing_through 123456fn another_function(mut passing_through: MyStruct) -&gt; MyStruct &#123; let y = vec![1, 2, 3]; // passing_through owns a deep copy of x' value that is be passing_through.x = x.clone(); return passing_through;&#125; 最后一个方法，在本例中vec![]是静态定义的，它可以移到函数参数中，这在有时候可能会需要一个显示的生命周期声明。 123456fn another_function&lt;'a&gt;(mut passing_through: MyStruct&lt;'a&gt;, x: &amp;'a Vec&lt;u32&gt;) -&gt; MyStruct &#123; // the compiler knows and expects a lifetime that // is at least as long as struct's of any reference passed in as x. passing_through.x = x; return passing_through;&#125; Lifetimes生命周期让很多Rust学习者遇到了很多编译错误，但随着2018版本的Non-Lecical-Lifetimes(NLL)的发布，更智能的生命周期检查器可以更好的检查借用规则和生命周期参数是否真正触发了错误，这可以让我们使用生命周期编写更灵活的代码。NLL不再是严格的词法检查器，它还会检查在上下文中是否真正用到了，只有真正用到了并且检查不合法才会报错。 Multiple owners std::rc::Rc&lt;T&gt; Rust中每个值只有一个owner，这固然很安全，但是并不是所有的场景都能满足。假设一个场景，你需要在循环里多次使用某个变量的值，而如果单个onwership那么在第一次循环的时候就会将ownership移交而剩下的循环则无法访问到有效的值，这显然不能满足我们的需求。 12345678910111213141516#[derive(Debug)]struct FileName &#123; name: String, ext: String,&#125;fn no_ref_counter() &#123; let name = String::from("main"); let ext = String::from("rs"); for _ in 0..3 &#123; println!("&#123;:?&#125;", FileName&#123;name, ext&#125;); // error: use of moved value: `name`, // value moved here in previous iteration of loop &#125;&#125; 一个可选的方法是在每次迭代中将name, ext进行clone，但克隆会产生完整的内存复制并降低整体的运行速度，为了解决这个问题，Rust引入了Rc类型，即reference counting引用计数类型。std::rc::Rc&lt;T&gt;将类型T装箱存储在堆heap上并返回一个不可变的引用，这个引用可以被低成本的clone（此时只有有一个新的引用被克隆在stack上，原有heap上的内存不变，注意这个新的引用也是不可变的）。这看起来就像是Rc&lt;T&gt;拥有在heap上的内存，然后在函数间进行传递并以此对堆上内存进行访问。只克隆引用计数和克隆完整的内存段相比，前者的代价就小多了。 1234567891011121314151617181920212223use std::rc::Rc;#[derive(Debug)]struct FileName &#123; name: Rc&lt;String&gt;, ext: Rc&lt;String&gt;,&#125;fn ref_counter() &#123; let name = Rc::new(String::from("main")); let ext = Rc::new(String::from("rs")); for _ in 0..3 &#123; println!("&#123;:?&#125;", FileName&#123; name: name.clone(), ext: ext.clone() &#125;); &#125; // output: // FileName &#123; name: "main", ext: "rs" &#125; // FileName &#123; name: "main", ext: "rs" &#125; // FileName &#123; name: "main", ext: "rs" &#125;&#125; 上述的代码解决了一个变量能多处访问的问题，但也仅仅是在单线程并且是不可变的scope中良好运行，在多线程中就行不通了。为了解决这个问题，Rust又引入了新的数据类型，且往下看！ Concurrency &amp; mutability Rust的内存管理是一个很强大的概念，可以轻松应对多线程并发和并行执行。Rust依托于其底层实现提供了和操作系统映射线程的API，比如Linux/Unix系统中的POSIX（The Portable Operatin System Interface）。当线程不涉及外部参数的时候还是很简单的，下面是一个示例： 123456789use std::thread;fn threading() &#123; // || 是参数部分，这里为空表示没有参数 let handle = thread::spawn(|| &#123; println!("Hello from a thread"); &#125;); handle.join().unwrap();&#125; 然而，当涉及外部变量在多线程之间的传递同步时，事情就没那么简单了，不过在进入到这个话题之前，让我们先来了解一个变量的可变性。 Immutable variables &amp; Interior mutability Rust中的变量默认是不可变的，如果需要可变则需要在声明的时候使用mut来显示定义，如let mut x = 10;。不可变的变量，可以避免数据竞争的出现，因为不涉及写操作。而显示声明mut可变则告诉编译器在哪里会产生写操作从而检查可能出现的数据竞争data race。这使得Rust在编译期间就能检查到可能存在的警告和错误，避免代码到了线上运行时才产生各种奇怪的事故现场。当然，如果可变的变量用的很少，那么你的情况将会简单的多。 还记得我们前文提到过的Rc吗？它是一个不可变的引用，但没有什么理由因为我们使用了一个不可变的引用，就不能修改装箱在堆上的变量，这就引入了Rust中的内部可变类型RefCell。RefCell对某个值维护了一个单一的owner并允许可变借用在运行期对其进行修改。和编译期错误不同的是，如果违反了相关的变量访问约束那么将会得到一个运行时panic!，这会导致程序奔溃。RefCell通常和Rc结合使用，用来提供有内部可变性的多个owner，而这多个owner变量之间，需要确保没有违反借用的2个规则。再来复习一下关于借用的2条规则： 1.Owners可以拥有immutable和mutable的reference，但不能同时存在两者 2.可以存在多个immutable reference，但mutabl reference只能存在一个 使用Rc来包装RefCell以达到多个owner，同时提供了一种方式可以改变变量的内容。这和传统语言的引用很像，在诸如Java或者C#语言中，典型的使用引用在函数调用中传递，而这些引用都直接指向内存中的实例变量，都能对其作出修改。 Rust中的Rc&lt;RefCell&lt;T&gt;&gt;这个模式，对实现复杂的程序和数据结构有着重要的影响，特别是对于一个变量来说因为它的所有权Ownership并不总是特别清晰的。比如在双向链表中的元素，分别有一个指针指向前面的元素和后面的元素，那么它们彼此之间谁拥有谁呢？而内部可变性告诉我们，它们可以同时拥有彼此。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950use std::cell:RefCell;use std::rc::Rc;#[derive(Clone)]struct Node &#123; value: String, next: Link, prev: Link, head: Link, tail: Link,&#125;type Link = Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;;impl Node &#123; pub fn new(value: String) -&gt; Node &#123; let node = Node &#123; value: value, next: None, prev: None, head: None, tail: None, &#125;; node.head = Some(Rc::new(RefCell::new(node))); node.tail = Some(Rc::new(RefCell::new(node))); node &#125; pub fn append(&amp;mut self, value: string) &#123; let new = Rc::new(RefCell::new(Node::new(value))); match self.tail().take() &#123; Some(old) =&gt; &#123; // by using `borrow_mut()`, the mutable reference only lives // as long as the assignment takes, thereby ruling out // creating a too-large scope and violating the borrowing rules. old.borrow_mut().next = Some(new.clone); new.borrow_mut().prev = Some(old; &#125;, None =&gt; self.head = Some(new.clone()), &#125; &#125; fn head() -&gt; Link &#123; unimplemented!() &#125; fn tail(&amp;self) -&gt; Link &#123; unimplemented!() &#125;&#125; 通过使用RefCell类型的borrow_mut()函数，Rust会检查并强制保证借用规则，如果有违反了借用规则则会产生panic!。到目前为止，通过使用Rc&lt;RefCell&gt;的复合类型，我们现在已经能够在多个地方(线程)对同一个变量进行访问和修改，不过此时的修改需要特别小心不能违反借用规则，即同一个作用域只能有一个运行时的可变借用在修改，否则会产生panic!。那么有没有办法可以让我们可以无惧的在多个线程中安全的访问和修改同一个变量呢？答案当然是可以，这就是Rust的Mutex类型！ Moving data 在介绍Mutex类型之前，让我们先来看一下单个线程是怎么使用外部变量的。上文提到，变量会在其离开scope作用域的时候被销毁，在函数定义域内声明的变量不能被外部引用，变量为了进入新的scope有时我们会移交ownership，而为了在多个scope之间能访问到同一个变量，我们使用了reference进行借用而不是移交ownership。同样的，线程需要使用外部的变量，可以通过移交所有权，也可以通过reference借用的方式，而移交所有权，有时也被称为Moving data，又称移动语义。下面来看一个对比： 123456789use std::thread;fn threading() &#123; let x = 10; let handle = thread::spawn(|| &#123; println!("hello from a thread, the number is &#123;&#125;", x); &#125;); handle.join().unwrap();&#125; 上面这段代码是编译不过的，因为println!()函数使用了x，但是编译器不知道外部的x变量和线程内使用的scope哪个生命周期更长，也就无法保证内存安全。为了在线程内安全的访问一个变量，编译器此时建议我们可以将x move in到线程的scope内，即像这样： 1234567fn threading() &#123; let x = 10; let handle = thread::spawn(move || &#123; println!("hello from a thread, the number is &#123;&#125;", x); &#125;); handle.join().unwrap();&#125; 上面的代码较之前的改动就是在线程的定义处加了一个move关键字，表示的是对线程内用到的外部变量进行move in，这样线程对其访问就是安全的，因为线程和变量的lifetimes是一样久的。然而，如果需要在线程间传递多个变量，或者实现Actor model角色模型，Rust标准库为此提供了channels信道。channels是一种single-consumer, multi-producer单个消费者多个生产者的队列，借助channels可以在多个线程中产生数据然后在单个线程内消费数据，下面是一个例子： 123456789101112131415161718192021use std::sunc::mpsc::&#123;channel, Sender, Receiver&#125;;fn channels() &#123; const N: i32 = 10; let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = channel(); let handles = (0..N).map(|i| &#123; let _tx = tx.clone(); thread::spawn(mvoe || &#123; _tx.send(i).unwrap(); &#125;); &#125;); // wait all threads finish for h in handles &#123; h.join().unwrap(); &#125; let numbers: Vec&lt;i32&gt; = (0..N).map(|i| &#123; rx.recv().unwrap() &#125;).collect(); println!("&#123;:?&#125;", numbers); // output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&#125; 有了channel这个消息队列，我们在线程间的通信就可以不用手动的对数据加锁并且可以免于因粗心而引入的bug。好了，到了这里，我们已经解决了在线程间通信的问题了，我们使用channel在多端产生数据然后在某个终端线程进行消费。但是如果我们想要在多个线程中都访问同一个共享变量呢？这个时候就需要在多个线程内对变量可见，同时还得满足借用规则，这就需要引入Rust的Mutex类型！Mutex，即mutual exclusion，写互斥的，简称互斥，在任何时刻只有单个线程取得某个变量的写权限。 Mutex互斥是编程中的一个古老的概念，所以Rust的标准库中就直接支持了。Mutex是如何使得在多个并发线程中访问同一个变量变得简单的呢？通过Mutex类型对某个变量进行装箱，它就可以在多个并发写的线程中保持互斥，这使得此时变量可以被多个写线程访问到。但是，此时那些线程还没有获得Mutex装箱类型的内存写权限。类似在单线程中我们使用Rc&lt;RefCell&gt;一样，我们首先对对单个变量使用RefCell装箱存储在堆上，然后使用Rc提供了多个可访问的借用owner。在多线程中，Rust提供了一个新的类型Arc(an aotimic reference counter)，原子计数器类型，通过Arc装箱的类型类似于单线程中dRc，也提供了多个可访问的借用owner，只不过到了多线程中它需要是原子性的，即多个线程对同一个变量的引用计数的增减必须同一时刻只有一个，不然会造成引用计数不同步的情况，这在某些情况下会造成变量提前释放或内存泄露的风险。就这样，结合Arc&lt;Mutex&lt;T&gt;&gt;，我们可以无畏的在多线程中对变量进行装箱读写，Arc保证了多线程间引用计数的准确性，Mutex提供了多线程间的互斥写。下面是一个例子： 12345678910111213141516171819use std::thread;use std::sync::&#123;Mutex, Arc&#125;;fn shared_state() &#123; let v = Arc::new(Mutex::new(vec![])); let handles = (0..10).map(|i| &#123; let numbers = Arc::new(&amp;v); thread::spawn(move || &#123; let mut vector = numbers.lock().unwrap(); (*vector).push(i); &#125;); &#125;).collect(); for handle in handles &#123; handle.join().unwrap(); &#125; println!("&#123;:?&#125;", *v.lock().unwrap()); // output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&#125; 虽然在多线程中推荐尽可能使用不可变的变量，但是Rust可以为我们提供在多线程中无畏安全的并发编程能力。 Send &amp; Sync Send, Sync这两个annotation是Rust多线程的基础准则，它们有着不同的作用： Send: 表示一个数据类型从一个线程send(move)移交到另一个线程是安全的，即不会发生内存段访问错误 Sync: 表示一个数据类型在线程间无需手动加锁或者进入临界互斥区即可共享 对于上述两个标记，Rust标准库为所有的基本类型都实现了，如果是基于基本类型构建的复合类型，那么也会自动实现这2个标记。但是，如果你想为自定义类型实现者2个标记，这是unsafe的，因为编译器无法得知你自定义的类型是否能在编译器的线程间安全的共享或者移交所有权，所以通常我们很少自定义这2个标记的实现。 以上，就是入门Rust语言重要的一章，Borrowing借用和Ownership所有权。让我们再来回顾一下Rust这门多编程范式的语言：它将数据data定义和行为实现behavior进行了强制分离，使用宏macros进行元编程，并借助所有权ownership来确定变量的生命周期lifetimes。知道变量的生命周期工作机制，就理解了为何Rust能去掉GC，同时也就理解了Rust是如何保证多线程的读写安全的。同时，在多线程和异步处理中，只有拥有变量的可变的所有权时才能对其进行修改，这很多时候是在编译期保证的，但是在运行时Rust依然能够保证其安全，真因为如此，Rust可以高效的避免了很多数据竞争的场景。 最后说点题外话，在我读这本《Hands-On Functional Programming in Rust 1st Edition》书之前，我完成了官网教程的《The Rust Programming Language》和《Rust by Example》，但直到读这本书的这一章，我才真正理解了Rust里面的数据额类型设计原来是这个意思。其实每个数据类型的出现，都是有它必然需要的场景，我们需要做的就是去了解它的设计背景，理解它的用法，从而将它牢牢掌握。最后，也都希望大家能够今早吃透Rust的数据类型设计，继续探索Rust后面更丰富的类型系统！]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Hands-On Data Structures and Algorithms with Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Rust中的类型设计 - Objects and behavior]]></title>
    <url>%2F2019%2F11%2F17%2Frust-data-type%2F</url>
    <content type="text"><![CDATA[数据类型是编程语言的基石。数据类型之于编程语言，就像26个字母之于单词、偏旁部首之于汉字，是构成程序语句最基础的元素，是我们编写statement/expression的literal，从本文开始我会涵盖Rust中常用的数据类型介绍和简单使用。 当今的许多编程语言都有多重编程范式设计，又称多范式编程语言（Multi-paradigm programming language），例如Java/Golang，但他们还停留在聚焦于对象继承原则，这也就是说它们会有classs、interfaces、class inheritance这些，而这些没有一个出现在Rust中，这也是造成很多人觉得Rust的学习曲线很陡的原因之一。Rust作为一个多重范式设计的语言，有很多函数式的概念和范式，而这些会使得应用传统的对象继承模式变得困难。与通过类classs和接口interfaces来组织代码不同的是，Rust使用struct和trait(特征)。下面就让我们开始探索，Rust中的独特设计究竟是怎样的一番体验，以及这些设计如何影响我们使用Rust中的数据结构来进行算法编程。 对象和行为 首当其冲的便是传统OOP语言中的类和继承机制。如果你写过OOP那么你对下面的这段代码将了如指掌： 1234567class Door &#123; private bool is_open = false; public void Open() &#123; this.is_open = true; &#125;&#125; 而在Rust语言中，这个模式定义要求所有Door的实例都拥有可变性，而可变性就涉及显示加锁以保证线程安全。与此同时，如果有新增一个类GlassDoor，这时如果没有类的继承机制那么就会产生重复的is_open定义，而重复代码将使得维护变得困难。 可变性mutability，在此处是Door实例对其内部数据is_open做出修改的能力。在Rust中所有变量默认都是不可变的，参见：rust-lang/rfcs#1 Rust建议使用trait实现共享的行为，Rust中的trait，中文译作特征，很像OOP语言中的虚类（trait的方法可以有默认实现，虚类也支持默认实现），Rust中的struct可以实现多个trait，下面是一个示例： 12345678910111213141516171819struct Door &#123; is_open: bool&#125;impl Door &#123; fn new(is_open: bool) -&gt; Door &#123; Door &#123; is_open: is_open &#125; &#125;&#125;trait Openable &#123; fn open(&amp;mut self);&#125;impl Openable for Door &#123; fn open(&amp;mut self) &#123; self.is_open = true; &#125;&#125; 使用类比，struct Door{} 的定义可以看成是OOP编程语言中的class，而 impl Door{} 块则类比class中的方法实现，trait Openable{} 则类比interface的定义，impl Openable for Door{} 在Rust中是为某个struct实现某个trait的功能，可类比OOP中实现一个interface。对比是为了参照理解，但绝不是只是换个名词，它体现的是Rust的设计思想：数据结构定义和行为实现分离，行为实现可插拔。 传统OOP语言中的类，把数据成员和方法实现糅杂在一起，虽然C++可以用头部文件.h把定义和实现区分开但并不是强制性的。而Rust强制把这两者区分开了，做法就是通过声明一个struct，以及一个impl块来承载struct中具体拥有哪些方法和具体实现。与此同时Rust可以为struct实现多个trait，这使得trait的导入、共享、复用变得简单。利用trait和generics泛型可以为已有struct真正无侵入的增加新trait的实现，下面就来展示一下。 假设我们已经有了一个分页的struct MyPaginate用来保存当前页数，以及对应的trait用来设置当前的页数和每页的条数，它们像下面这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546trait Page &#123; fn set_page(&amp;mut self, p: i32);&#125;trait PerPage &#123; fn set_perpage(&amp;mut self, num: i32);&#125;#[derive(Debug)]struct MyPaginate &#123; page: i32, per_page: i32,&#125;impl MyPaginate &#123; fn member_method(&amp;self) &#123; println!("This is member method for struct which no relevant to trait."); &#125;&#125;impl Page for MyPaginate &#123; fn set_page(&amp;mut self, p: i32) &#123; self.page = p; &#125;&#125;impl PerPage for MyPaginate &#123; fn set_perpage(&amp;mut self, per_page: i32) &#123; self.per_page = per_page; &#125;&#125;#[cfg(test)]mod tests &#123; #[test] fn test_trait_not_inherit() &#123; let mut my_paginate = MyPaginate &#123; page: 1, per_page: 10, &#125;; my_paginate.set_page(2); my_paginate.set_perpage(100); println!("my_paginate: &#123;:?&#125;", my_paginate); // output: my_paginate: MyPaginate &#123; page: 2, per_page: 100 &#125; &#125;&#125; 上面定义了2个trait并为struct实现了这2个trait，到这里还显示不出Rust中的trait有什么特别的地方，让我们接着往下看。假如这时我们需要引入一个新的trait并增加一个方法set_skip_page，希望能够设置可以跳过的页数，这个时候如何添加到代码中去呢？如果是在C中，接口是由抽象类来实现，而由于C只能单继承，如果要引入新的方法实现，那么我们势必需要在现有的抽象类/子类中新增方法实现，这就会侵入现有代码。而在Java中，接口通过interface来实现，类可以继承多个interface，如果我们要新增一个方法实现，我们可以引入新的interface，这样可以不改动已有的interface代码，但至少还得修改类定义新增一个 extends interface的声明。而在Rust中，上述2种情况都不需要修改！这得益于Rust中的generics和trait，给代码提供了强大的灵活性和表达性，下面看代码示例： 12345678910111213141516171819202122232425// 声明了一个新`trait`trait Paginate &#123; fn new_method(&amp;self, page: i32);&#125;// 为MyPaginate实现新traitimpl Paginate for MyPaginate &#123; fn new_method(&amp;self, page: i32) &#123; println!("In new_method, page: &#123;&#125;", page); &#125;&#125;#[cfg(test)]mod tests &#123; #[test] fn test_new_trait() &#123; let mut my_paginate = MyPaginate &#123; page: 1, per_page: 10, &#125;; my_paginate.member_method(); my_paginate.new_method(10); // output: In new_method, page: 10 &#125;&#125; 上面的例子是新增一个独立的trait实现，可以看到Rust可以在真正零侵入原struct和trait的情况下，为struct实现了新trait的方法！这是不是比C++/Java更灵活呢？而且，结合trait inheritenceRust还能实现更强大的功能。下面来看一个需求，假设你的需求是新增一个新trait实现，但是实现这个trait的前提是你需要先实现Page，但是你又希望在设计上将两者区分开而不是糅杂在一起，这个时候trait inheritence就派上用场了，看例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 1.第一种语法为MyPaginate声明实现Paginate trait，Paginate需要依赖于Pageimpl Paginate for MyPaginate// where限定符声明了该实现针对的MyPaginate类型需要先实现了Page trait，// 这是因为新增的方法实现用到了Page trait中的set_page函数where MyPaginate: Page,&#123; fn set_skip_page(&amp;mut self, page: i32) &#123; self.set_page(page + 1); &#125;&#125;#[cfg(test)]mod tests &#123; #[test] fn test_trait_inherit() &#123; let mut my_paginate = MyPaginate &#123; page: 1, per_page: 10, &#125;; my_paginate.set_page(1); my_paginate.set_perpage(100); my_paginate.set_skip_page(12); println!("my_paginate: &#123;:?&#125;", my_paginate); // output: my_paginate: MyPaginate &#123; page: 13, per_page: 100 &#125; &#125;&#125;// 以上是针对单个具体类型MyPaginate为其实现了Paginate实现，// 而Rust的泛型提供了更强大便捷的语法，可以为所有符合要求的类型实现Paginate，请看：// 2.声明trait的时候使用继承语法，表示实现PaginateInherit trait之前需要先实现Page traittrait PaginateInherit: Page &#123; fn set_skip_page_inherit(&amp;mut self, page: i32);&#125;// 为实现了Page的类型T实现PaginateInherit，也就是为目标类型实现PaginateInherit trait而已impl&lt;T: Page&gt; PaginateInherit for T &#123; fn set_skip_page_inherit(&amp;mut self, page: i32) &#123; self.set_page(page + 1); &#125;&#125;// 而在此处的上下文中我们已实现了 impl Page for MyPaginate &#123;&#125;// 所以此时MyPaginate就自动实现了PaginateInherit！#[cfg(test)]mod tests &#123; #[test] fn test_trait_inherit() &#123; let mut my_paginate = MyPaginate &#123; page: 1, per_page: 10, &#125;; my_paginate.set_page(1); my_paginate.set_perpage(100); my_paginate.set_skip_page_inherit(12); println!("my_paginate: &#123;:?&#125;", my_paginate); // output: my_paginate: MyPaginate &#123; page: 13, per_page: 100 &#125; &#125;&#125; 综上，我们展示了Rust如何使用struct和trait（特征）将数据结构定义和行为实现相分离，Rust推荐优先使用组合而不是继承。通过将数据结构和行为实现相分离，不仅仅是编码语法上的改变，更是从设计思想上出发，将现实世界中的数据和行为抽象解耦，使多变的行为得以灵活扩展而不必影响少变的数据结构定义或干扰已有行为定义和实现。这将大大提高我们对现实的抽象灵活表达能力，而这，也将有助于我们打造出更安全可靠的系统，你觉得呢？]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Hands-On Data Structures and Algorithms with Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust入门简介]]></title>
    <url>%2F2019%2F11%2F16%2Fhello-rust%2F</url>
    <content type="text"><![CDATA[前段时间一个偶然的机会了解到了 Rust 这门语言，随机就被它的Slogon俘获了：A language empowering everyone to build reliable and efficient software. Rust能够在编译期间就确保内存安全、提供和C/C++同级别的高性能、还有并发、异步、函数编程、强大的宏等等特性，并且很重要的一点是整个Rust社区很友好，而且Rust的工程学用起来体验很好。随着了解的越多，被种草的程度就越深，虽然现在学习到的Rust知识还很少（Rust的中文资料相对较少），但基本确定了会一直学习下去的，希望在未来Rust的许多设计思想可以普及开来，比如内存安全的思想、软件工程学等等。 内存安全的意思，可以简单理解为编译通过的程序里不会在运行时出现空指针/悬垂指针。 我相信写过C/C++/JAVA代码的同学都有遇到过空指针异常的，而很多软件漏洞都是内存泄露/空指针造成的， 如果你有过在某个深夜排查空指针异常Bug的经历，你就会明白内存安全是多么的具有吸引力！ 想象一下你很有自信发布代码，因为你知道不会出现内存安全问题，是不是很期待？ （特别是当你涉及交付产品给终端用户的时候就更能体会到这种感觉了，比如一些安全敏感的应用，如金融、医疗等等） 下面，就请跟随我的脚步，来简单的了解一下Rust这门语言，看看它和其他已有的语言和哪些不同，我们可以从这些差异点中进行学习借鉴。 选择Rust的三大理由 首先来看到Rust官网首页列出的选择Rust的三大理由： 高性能：Rust是一个没有GC的语言，并且几乎没有运行时开销，可以胜任对性能要求特别高的场景，不会因为GC而导致程序的“暂停”。同时Rust依靠独特的Ownership和Lifetimes的设计，使得其内存利用率极高，不会像JAVA程序那样把所有的内存吃光，相反，使用Rust编写的程序在保持高性能的同时还能做到内存资源占用少，在节省服务器资源的同时可以让我们更有信心应对更严酷的场景。 可靠性：Rust可靠性前面有提到一点，就是内存安全，其实Rust还可以保证线程安全，在进行多线程进行并发/异步的同时，不会出现Data Racing的问题，而Data Racing是其他编程语言中多线程并发绕不过的问题。而这些特性，都得益于Rust丰富的Type系统和Ownership机制。 生产力：上手Rust给我的体验是，这是一门工程学设计良好的语言。集构建、测试、文档、发布于一体的开发工具Cargo和crates.io，更简约友好的命名规范，能减少大量样板代码的宏以及库函数。举2个例子来感受一下，函数声明，Go中使用func(){}，而Rust则更进一步使用fn(){}，也许你会觉得这只是几个字符的差别，但远远不止，它体现出Rust精简的设计思想。比如输出语句，Go中需要先导入import fmt然后再使用fmt.Println()，而Rust强大的宏更进一步无需导入任何包直接使用println!()就可以打印到控制台。诸如此类的还有许多，它体现出的是在开发过程中提升开发人员的效率，工程学友好，Rust刷新了我对这个词的理解。 Rust的发展历史和生态现状 Rust最开始是2006年Graydon Hoare设计的私人项目，其后在2009年Mozilla（Firefox的母公司）决定赞助这个项目，并在2010年首次对外公开。同年，Rust的编译器rustc的源代码由OCaml语言转移到用Rust语言（进行bootstrapping自举），并于2011年实际完成，这个可自我编译的编译器采用了LLVM作为它的后端。rustc的第一个公开版本发布是在2012年1月，Rust在2015年5月15日发布了它的第一个稳定版本Rust 1.0。截止到文本撰写时，Rust发布了它的最新的版本Rust 1.39.0，期待已久的async/await特性终于稳定了。 其中Rust在Mozilla被用来了整个重构重写了FireFox的核心组件，足以证明Rust能够胜任大型软件的开发重构工作。 Rust的发展方面，与之可以比对的是时下流行的Go语言。Rust和Go几乎是同时出来的语言，都是在2009年左右。Go语言伴随着Docker/Keburnetes容器编排、微服务技术潮流的兴起，可以说是增长势头迅猛。反观Rust，每一个特性设计都讨论好久，前期的版本变化太大，很多设计都推倒重来（比如是否要有GC），直到1.0版本出来后才趋于稳定（值得注意的是Golang 1.0的版本发布时间是2012年3月，Rust与之相比晚了3年多才发布1.0版本）。这在一定程度上延缓了Rust的普及，但也因此造就了Rust独特的设计理论、良好的社区文化以及友好的工程学体验。虽然没有Google这个好爹的背书，但是Rust无运行时开销的高性能和无畏安全的线程并发能力、工程学效率，我相信会越来越受到欢迎的。 下面引用Rust的一则报道加以补充： 目前，Rust发展势头正劲。此前，微软安全响应中心探索采用 Rust 的消息引发大量关注，在连续四年蝉联“最受开发者喜爱的编程语言”后，Rust 可能已经从“想要学习的语言”逐渐转变为许多开发者“正在学习的语言”。自从四年前首次发布稳定版以来，它已经得到了广泛的采用，谷歌，微软和 Mozilla 等公司都在使用 Rust。现在，AWS 也向 Rust 伸出了橄榄枝。 至于Rust的生态方面，使用Rust几乎能做任何事情：可以编写底层应用操作系统，可以进行Web开发、嵌入式开发，还可以利用WebAssembly将Rust代码运行在浏览器中。来一张官网的图感受一下： 关于Rust 2018年的Road Map可以参见：https://blog.rust-lang.org/2018/03/12/roadmap.html。 不过Rust现在的一些基础库还不够完善，还需要更多的开发者加入添砖加瓦。 未来的互联网，随着5G的普及，注重安全和高性能是必然趋势，而Rust正是这样的一门可以赋予每个人无畏的构建安全高性能的语言。借助Rust，我相信可以摆脱系统对架构集群的过度依赖，构建出安全、高性能、设计简约的轻型系统。下一篇文章，我将继续带领大家，来理解Rust中的数据类型。 最后，附上学习Rust的资源链接： Rust Programming Language The Rust Programming Language Forum Rust Language (@rustlang) / Twitter Rust - MozillaWiki The Rust Programming Language Blog Introduction - The Rust RFC Book This Week in Rust Baby Steps - Nicholas D. Matsakis Rust Playground Rust语言中文社区-首页 Rust Force - 关于 Rust 编程语言的一切]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Hands-On Data Structures and Algorithms with Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务引发的一次线上Bug]]></title>
    <url>%2F2019%2F11%2F16%2Fmysql-transacion-with-proxy%2F</url>
    <content type="text"><![CDATA[上篇博文里谈到，我最近在做的是组内的一个客服场景下的即时聊天框，前两周的周五赶马上线了。在测试环境测试一切正常，上线后…就翻车了…当时赶着上线，是在周五开完周会之后我和另一个组员一起上线的。那晚数据库还是临时找DBA给申请的，然后上线后我才把之前一条应该刷的SQL给刷了…所以赶着上线真的不是一件好事，在实际开发过程中要尽量避免，这次案例就引以为戒吧。 先来描述一下故障表现：我们上线之后，在用户向服务方发起在线咨询时后台会生成一个群聊记录 os_group，此时问题就出现了，前端调用接口获取到的群聊成员列表都是空的，用户发起群聊后却看不到群聊中的任何成员，数据异常，而且多次测试中还偶然有正常的。 到这里是我们始料未及的，在测试环境我们测试了一周都没有出现这个现象，此时我的第一反应，在确认接口返回的数据确实有问题后，先在脑海里过一遍，有没有可能是代码哪个环节没考虑到导致了这个问题。在确定没有直接能判断到可能的源头后，开始了排查。首先通过跳板机连接到线上的数据查看相关的数据是否插入正常，一查询发现获取群成员列表接口中的 group_id: 0 在数据库表中确实也是0，这基本就锁定了是我们连MySQL出了问题。异常的数据截图如下： 接着顺藤摸瓜，找到了代码中插入群聊的位置： 这里解释一下：75行之前把要创建群聊的前置条件都准备好，然后调用 dao.insertSelective(groupDO) 进行数据插入，初始化好群聊记录后，接着初始化群成员关系 initGroupUsers()，其中就用到了群聊Id groupDO.getId()。用过ORM框架的朋友们都知道，insert 方法都会将插入那行数据的 id 返回并设置到dao对象中，在此处也即 groupDO 中，然后后续初始化群成员关系的时候就会用到。问题也就是出现在这里，插入后的dao对象的id从效果上看并没有返回设置对应的id，导致初始化群成员关系的时候 group_id 都是0，从而导致了在前端页面数据异常，新建的群聊没有任何成员显示。 到这里问题基本就确定了，是MySQL连接的问题。一开始我们怀疑是临时申请的数据库哪个设置没配（因为在申请数据库的时候DBA跟我说还有一个操作是初始化），不过在和DBA拉群沟通的时候，DBA表示配置都是标准化的并没有遗漏。这时我的另一个组员，也就是这次一起上线的那位，说他之前就遇到过一次DBA申请的数据库在挂了MiProxy之后存在数据同步不一致的问题（MiProxy是MySQL前面的一层代理，是DBA用来做负载均衡的，如果直接连接MySQL后端的话是没有负载均衡的）。这时候我们继续跟DBA沟通，DBA让我们优先排查代码的问题，虽然之前MiProxy出现过主从同步不一致的问题，但遇到客户端不兼容的情况还是极少的。并让我们贴出了有问题的代码： 这段代码看起来没有问题，先insert然后再select最新的LAST_INSERT_ID()。这时候我们分别去验证数据库连接的问题：DBA验证MiProxy的问题，我们验证程序的问题，我们在线上把这个组件的数据库切换到staging环境后就好了，插入的id是能查到的不再为空了，同时DBA那边也用脚本验证了MiProxy的连接是没有问题的： 到这里我们综合以上信息，脚本使用pymysql.connect()连接线上MiProxy，在同一个打开的connection里面insert/select都是没有问题的；而程序中使用了MyBatis Plus进行连接MiProxy就有问题，但是程序连接staging环境的库没有问题，同时线上库和staging库的区别在于一个是直连的、一个是使用MiProxy连接的；再结合多次测试中还是偶有能正确插入的，这个时候我们就想到可能是MySQL连接多线程的问题，使用单个连接没有问题，可以排除数据库配置、驱动版本的问题，而使用MiProxy连接后就不正常了，MiProxy提供代理能力，其后面屏蔽掉了可能有多个mysql connection线程，而程序代码中的select/inset有2次读写操作，需要先写入然后再去读取，如果这2个操作不在同一个后端MiProxy的connection线程中，则其执行的先后顺序得不到保障，比如select读取的线程总是先返回，那么插入的os_group表的最新的id便是不正确的，从而导致了每次读取到的os_group的id都是0。 到这里问题基本明朗了，是由于数据库代理引发的读写不同步的问题，之前同事就遇到过相关的配置问题，需要开启数据库的配置keep_session来保持会话信息。按理说这里我们也让DBA直接开启keep_session，这样select/insert就能在同一个连接里完成也就不会出现不同步的问题了。但是我的那位同事之前就遇到过开了keep_session之后，经过MiProxy提供的主从库有不同步的问题，所以这里我们并不能通过这个开关配置来最终解决问题。 怎么办呢？我们提议让DBA不要再走MiProxy了，我们想直连后端mysql。DBA不建议这样做，说还是有负载均衡比较好，可是开了keep_session之后又有主从不同步的可能问题，两边都不是。最后的最后，还是我们这边决定先在代码层面对相关的查询位置进行事务处理，明确声明让MiProxy后端放到同一个connection里处理，我们在Service层都加了Transactional注解： 我们在Service层都加了事务开启，这样确保了所有的SQL查询都在事务里，不会出现上述读写不同步的问题。可能到这里你会问所有的查询都开事务，MySQL读写的性能是不是会下降？那是肯定的，但是鉴于我们目前服务的阶段是处于快速上线验证的阶段，所以此次我们先临时fix一下，后面等业务量上来了如果确实性能跟不上，到时候再优化也不迟。 其实这里应该说是基础组件的问题，DBA提供的主从同步数据库有些场景功能满足不了，从而导致了当前的使用现状。 哎，基础设施不够完善啊，要想跑得快，还得底盘好，这话没毛病。 临时fix掉后我们重新部署，上线后再验证就没有这个问题了，总算是好事多磨，而此时已经是周五晚上接近9点了。不过这次上线也是应该要上的，因为项目Owner在周报里已经写了上线日期就是今天，中间出现的这些小插曲，说明我们项目管理这次做得不够好。 不幸中的万幸是，此次我们组件上线是有灰度的，只有开启了组件可见的服务才能看到我们的入口，而这次上线我们只开启了自己的服务可见，对其他服务来说是无感知的，这也体现了要想持续快速交付，无缝的灰度上线策略是必不可少的。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS长整型精度问题引发的一个Bug]]></title>
    <url>%2F2019%2F11%2F03%2Fjs-floating-point-precision%2F</url>
    <content type="text"><![CDATA[最近在做一个IM相关应用的后端接口工作，在前后端联调的过程中出现了一个因JS浮点数精度引发的bug，记录如下。 先简单的介绍下我正在做的工作，我们在做的事情是基于公司云平台的产品探索，目前小组负责的探索方向有反馈系统、技术社区、产品点评、需求发布等，而我所在的小组是反馈系统里面衍生的在线支持。在线支持需要连接服务方和用户方，这里的服务方可以理解为淘宝卖家，不过在我们云平台上是技术能力提供方（比如FDS/HBase等），而反馈系统和在线支持，就充当起淘宝旺旺的功能，给商家和用户建立一个渠道，方便快速接入用户并解答疑问，同时还基于内部Jira系统将用户数据提交成需求单/缺陷单/建议单等，进一步提升技术迭代速度、提升用户使用体验、助力业务领跑。 介绍完背景后，让我们来看下具体出现bug的场景： 我们第一版实现的是网页群聊，是基于小米开源的MIMC来实现的。其中获取用户群聊未读消息条数的逻辑，是基于MIMC回调消息和前端在收到消息后向后端更新已读的sequence来做的。举个例子就是群聊G发送了a,b,c三条消息，用户U上次已读消息的sequence号是a的sequence号，所以此时a在群聊G有2条未读消息（消息b,c都不是用户U发的），当用户点进群聊的时候，前端取最后一条消息的sequence向后端接口更新用户的已读消息sequence。到了这里一切看起来都没有问题，但是联调过程中出现了群聊未读消息更新不成功，多次更新后依然还是会有一条未读消息的现象… 首先观察接口返回，在chrome浏览器里面F12 preview看接口返回数据，初看起来获取到的sequence返回正常，然后再去看k8s里面pod的日志，前端-&gt;后端-&gt;MIMC-&gt;MIMC回调，一切交互逻辑也是OK的。此时仔细观察了数据库里面更新回来的sequence序列号，和日志中发送给MIMC也是一致的，这个时候再去看接口中显示的群聊历史消息的sequence，此时发现了一个问题：群聊历史消息接口获取到的sequence序列号总是比收到MIMC回调的sequence小1，而在浏览器中观察接口的返回发现，Preview里面预览看到的结果，和Response里面的结果相差1！问题就在这，如下图所示： 注意看红色圈出来的部分相差1，这就是导致sequence更新不正常的元凶！ 问题找到了，想到了可能是JS的精度问题，因为对JS了解的不多想着返回long型了也不是浮点数，怎么就不能精确表示了呢？看着也不像整型溢出，于是google了一下，了解到原来JS对所有的数字都使用64位浮点数表示，而浮点数虽然能表示范围很大，但是在一些大整数的时候存在不能精确表示的问题，比如上图中差1的情况，具体原因是因为在64位浮点数表示里面，只有52位是真正用来表示尾数部分的，而剩下的12位则用来表示指数和符号位，通过正规化，我们可以使用53位来表示尾数（+符号位），因此，64位浮点数能表示的尾数最大值是：2^53-1（9007199254740991），而我们接口中返回的157180098717096001远超过9007199254740991，从而JS不能精确的表示，出现了精度问题。stackoverflow上面的解释如图： 好了，到了这里终于是水落石出了，知道原因后要解决这个问题也很简单，那就是将返回字段的类型由long改为String，这样前端就能准确的获取到不会有精度问题，而且String类型也能满足我们的场景需要：群聊消息排序、更新已读sequence等。再补充一下，这里sequence使用long存储而不是String，是因为MIMC的SDK中返回的sequence就是long型的。 吃一堑，长一智。通过这个问题，我们深刻的理解了JS和前后端数据交互中可能存在的精度表达问题（准确来说是浮点数不能精确表示的问题，因为这里JS默认都使用了64位浮点数表示数字），针对这个问题NodeJs等也有自己的一个精确表示大整数数字的库来解决。作为后端开发的我们，平时多了解一下上下游的知识还是很有帮助的；再有一个就是，当时我遇到这个问题的时候，第一个感觉就是这个问题很有意思，激起了我的排查兴趣，虽然排查过程不算复杂，但是一个积极的心态对推进bug排查很有帮助的，用积极的心态去看待问题，把问题当做学习成长的机会，你将会活在当下。Coding in the moment. :-)]]></content>
      <categories>
        <category>Web</category>
        <category>Front-end</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朝花夕拾]]></title>
    <url>%2F2019%2F08%2F31%2Ffirst-post%2F</url>
    <content type="text"><![CDATA[在重写博客之际，感慨恒劳知逸、君子慎独、]]></content>
  </entry>
</search>
